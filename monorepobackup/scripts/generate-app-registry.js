#!/usr/bin/env node

/**
 * App Registry Generator
 * 
 * Automatically discovers learning apps and generates the app registry.
 * This replaces manual maintenance of lib/appRegistry.js
 * 
 * Usage:
 *   node scripts/generate-app-registry.js [--output=path/to/output.js] [--dry-run]
 * 
 * Discovery Rules:
 * - Scans apps/learn-* directories
 * - Requires package.json with dev port
 * - Detects content structure (content/ directory)
 * - Extracts app metadata from package.json or defaults
 * - Maintains main app entry manually (since it's special)
 */

const fs = require('fs');
const path = require('path');

// Parse command line arguments
const args = process.argv.slice(2);
const outputPath = args.find(arg => arg.startsWith('--output='))?.split('=')[1] || path.join(__dirname, '..', 'lib', 'appRegistry.js');
const dryRun = args.includes('--dry-run');

/**
 * Extract port from package.json dev script
 */
function extractPort(packageJson) {
  const devScript = packageJson.scripts?.dev || '';
  const portMatch = devScript.match(/-p\s+(\d+)/);
  return portMatch ? parseInt(portMatch[1]) : null;
}

/**
 * Discover all learning apps
 */
function discoverApps() {
  const appsDir = path.join(__dirname, '..', 'apps');
  const allApps = fs.readdirSync(appsDir);
  const learningApps = [];

  for (const appDir of allApps) {
    if (!appDir.startsWith('learn-')) continue;

    const appPath = path.join(appsDir, appDir);
    const packageJsonPath = path.join(appPath, 'package.json');
    
    if (!fs.existsSync(packageJsonPath)) {
      console.warn(`Warning: ${appDir} has no package.json, skipping`);
      continue;
    }

    const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
    const port = extractPort(packageJson);

    if (!port) {
      console.warn(`Warning: ${appDir} has no port in dev script, skipping`);
      continue;
    }

    // Check if app has content structure
    const contentDir = path.join(appPath, 'content');
    const hasContent = fs.existsSync(contentDir);

    // Extract app name (remove 'learn-' prefix and capitalize)
    const appId = appDir;
    const appName = packageJson.name || appDir
      .split('-')
      .map(word => word.charAt(0).toUpperCase() + word.slice(1))
      .join('-');

    // Check if it's a free app (e.g., cricket)
    const isFree = appDir === 'learn-cricket';

    learningApps.push({
      id: appId,
      name: appName,
      subdomain: appId,
      primaryDomain: `app1.${appId}.iiskills.cloud`,
      localPort: port,
      postLoginRedirect: '/learn',
      postRegisterRedirect: '/learn',
      features: ['simplified-registration', 'courses'],
      isFree,
      hasContent
    });
  }

  // Sort by port for consistency
  learningApps.sort((a, b) => a.localPort - b.localPort);

  return learningApps;
}

/**
 * Generate the app registry file content
 */
function generateRegistryContent(apps) {
  const timestamp = new Date().toISOString();
  
  let content = `/**
 * Multi-App Registry
 * 
 * AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
 * Generated on: ${timestamp}
 * Generated by: scripts/generate-app-registry.js
 * 
 * To regenerate: npm run generate:registry
 * 
 * Centralized configuration for all iiskills.cloud applications.
 * This registry enables:
 * - Dynamic app-specific redirects after authentication
 * - Consistent app metadata across the platform
 * - Easy addition of new apps to the ecosystem
 * - Cross-app navigation and session management
 */

/**
 * App Registry - Defines all applications in the iiskills.cloud ecosystem
 * 
 * Each app entry includes:
 * - id: Unique identifier for the app
 * - name: Display name
 * - subdomain: Subdomain (or null for main domain)
 * - primaryDomain: Full domain name for production
 * - localPort: Development port
 * - postLoginRedirect: Path to redirect after successful login
 * - postRegisterRedirect: Path to redirect after registration
 * - features: List of enabled features for this app
 * - isFree: Whether app is free to access (no payment required)
 */
export const APPS = {
  // Main app - manually maintained
  main: {
    id: 'main',
    name: 'iiskills.cloud',
    subdomain: null,
    primaryDomain: 'app.iiskills.cloud',
    localPort: 3000,
    postLoginRedirect: '/dashboard',
    postRegisterRedirect: '/dashboard',
    features: ['full-registration', 'dashboard', 'admin'],
    isFree: false,
  },
`;

  // Add discovered apps
  for (const app of apps) {
    content += `  '${app.id}': {
    id: '${app.id}',
    name: '${app.name}',
    subdomain: '${app.subdomain}',
    primaryDomain: '${app.primaryDomain}',
    localPort: ${app.localPort},
    postLoginRedirect: '${app.postLoginRedirect}',
    postRegisterRedirect: '${app.postRegisterRedirect}',
    features: ${JSON.stringify(app.features)},
    isFree: ${app.isFree},
  },
`;
  }

  content += `};

/**
 * Get app configuration by ID
 * @param {string} appId - The app identifier
 * @returns {Object|null} App configuration or null if not found
 */
export function getAppById(appId) {
  return APPS[appId] || null;
}

/**
 * Get app configuration by subdomain
 * @param {string} subdomain - The subdomain (or null for main domain)
 * @returns {Object|null} App configuration or null if not found
 */
export function getAppBySubdomain(subdomain) {
  return Object.values(APPS).find(app => app.subdomain === subdomain) || null;
}

/**
 * Get app configuration by full domain
 * @param {string} domain - The full domain name
 * @returns {Object|null} App configuration or null if not found
 */
export function getAppByDomain(domain) {
  // Strip protocol if present
  const cleanDomain = domain.replace(/^https?:\\/\\//, '').split(':')[0];
  return Object.values(APPS).find(app => app.primaryDomain === cleanDomain) || null;
}

/**
 * Get current app configuration based on environment
 * Detects from browser hostname or NEXT_PUBLIC_APP_ID env variable
 * @returns {Object} App configuration (defaults to main if not detected)
 */
export function getCurrentApp() {
  // Try environment variable first
  const envAppId = process.env.NEXT_PUBLIC_APP_ID;
  if (envAppId && APPS[envAppId]) {
    return APPS[envAppId];
  }

  // In browser, detect from hostname
  if (typeof window !== 'undefined') {
    const hostname = window.location.hostname;
    
    // Check for localhost with port
    if (hostname === 'localhost' || hostname === '127.0.0.1') {
      const port = parseInt(window.location.port);
      const appByPort = Object.values(APPS).find(app => app.localPort === port);
      if (appByPort) return appByPort;
    }
    
    // Check by domain
    const appByDomain = getAppByDomain(hostname);
    if (appByDomain) return appByDomain;
    
    // Check by subdomain
    const subdomain = hostname.split('.')[0];
    const appBySubdomain = getAppBySubdomain(subdomain === 'app' ? null : subdomain);
    if (appBySubdomain) return appBySubdomain;
  }

  // Default to main app
  return APPS.main;
}

/**
 * Get all free apps
 * @returns {Array<Object>} Array of free app configurations
 */
export function getFreeApps() {
  return Object.values(APPS).filter(app => app.isFree);
}

/**
 * Get apps accessible to a user based on their subscription
 * @param {Object} user - User object with subscription info
 * @param {boolean} isAdmin - Whether user is an admin
 * @returns {Array<Object>} Array of accessible app configurations
 */
export function getAccessibleApps(user, isAdmin = false) {
  if (isAdmin) {
    return Object.values(APPS);
  }

  if (!user) {
    return getFreeApps();
  }

  // If user has active subscription, return all apps
  if (user.subscription_status === 'active') {
    return Object.values(APPS);
  }

  // Otherwise only free apps
  return getFreeApps();
}

/**
 * Get appropriate redirect URL after authentication
 * @param {Object} context - Context with app info and auth state
 * @returns {string} Redirect URL
 */
export function getAuthRedirectUrl(context) {
  const { app, isLogin, isRegister } = context;
  
  if (!app) return '/';
  
  if (isLogin) {
    return app.postLoginRedirect || '/';
  }
  
  if (isRegister) {
    return app.postRegisterRedirect || '/';
  }
  
  return '/';
}

/**
 * Generate full URL for an app
 * @param {string} appId - App identifier
 * @param {string} path - Path within the app (optional)
 * @returns {string} Full URL
 */
export function getAppUrl(appId, path = '/') {
  const app = getAppById(appId);
  if (!app) return '/';

  // In development, use localhost
  if (process.env.NODE_ENV === 'development') {
    return \`http://localhost:\${app.localPort}\${path}\`;
  }

  // In production, use primary domain
  return \`https://\${app.primaryDomain}\${path}\`;
}

/**
 * Get navigation items for app switcher
 * @param {Object} user - Current user
 * @param {boolean} isAdmin - Whether user is admin
 * @returns {Array<Object>} Navigation items
 */
export function getAppNavigationItems(user, isAdmin = false) {
  const accessibleApps = getAccessibleApps(user, isAdmin);
  
  return accessibleApps.map(app => ({
    id: app.id,
    name: app.name,
    url: getAppUrl(app.id),
    isFree: app.isFree,
  }));
}

/**
 * Get total number of apps
 * @returns {number} Total app count
 */
export function getTotalApps() {
  return Object.keys(APPS).length;
}

/**
 * Get all app IDs
 * @returns {Array<string>} Array of app IDs
 */
export function getAllAppIds() {
  return Object.keys(APPS);
}
`;

  return content;
}

/**
 * Main execution
 */
function main() {
  console.log('üîç Discovering learning apps...');
  const apps = discoverApps();
  
  console.log(`‚úÖ Found ${apps.length} learning apps:`);
  apps.forEach(app => {
    console.log(`   - ${app.id} (port ${app.localPort})${app.isFree ? ' [FREE]' : ''}${app.hasContent ? ' [HAS CONTENT]' : ''}`);
  });

  console.log('\nüìù Generating app registry...');
  const content = generateRegistryContent(apps);

  if (dryRun) {
    console.log('\n--- DRY RUN - Generated Content Preview ---');
    console.log(content.substring(0, 1000) + '\n...\n(truncated)');
    console.log('\n‚ÑπÔ∏è  Dry run complete. No files were modified.');
  } else {
    // Backup existing file if it exists
    if (fs.existsSync(outputPath)) {
      const backupPath = outputPath + '.backup';
      fs.copyFileSync(outputPath, backupPath);
      console.log(`üì¶ Backed up existing registry to ${backupPath}`);
    }

    fs.writeFileSync(outputPath, content, 'utf8');
    console.log(`‚úÖ Generated app registry at ${outputPath}`);
    console.log(`   Total apps in registry: ${apps.length + 1} (including main)`);
  }
}

// Run if called directly
if (require.main === module) {
  main();
}

module.exports = { discoverApps, generateRegistryContent };
