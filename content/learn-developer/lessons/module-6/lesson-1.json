{
  "moduleId": 6,
  "lessonId": 1,
  "slug": "authentication-security",
  "title": "Authentication & Security",
  "isFree": true,
  "content": "<h2>Module 6, Lesson 1: Authentication &amp; Security</h2>\n\n<h3>Introduction</h3>\n<p>Security is not a feature to add at the end — it's an architectural concern woven through every layer of your application. The most common web vulnerabilities (SQL injection, XSS, CSRF, insecure authentication) are well-understood and preventable. Understanding them deeply means you stop writing code that needs patching later.</p>\n\n<h3>Key Concepts</h3>\n<h4>Authentication vs Authorisation</h4>\n<p><strong>Authentication</strong> answers \"who are you?\" — verifying identity via passwords, tokens, or biometrics. <strong>Authorisation</strong> answers \"what are you allowed to do?\" — controlling access to resources. Conflating the two is a source of security bugs. Authenticate first, authorise second, always.</p>\n<h4>JWT and Session-Based Auth</h4>\n<p><strong>Sessions</strong> store state server-side and give the client only an opaque session ID in a cookie. <strong>JWTs</strong> (JSON Web Tokens) are self-contained tokens signed with a secret. They enable stateless, scalable auth but require careful handling: never store JWTs in localStorage, set short expiry times, and always verify the signature.</p>\n<h4>Common Vulnerabilities</h4>\n<p><strong>SQL Injection</strong>: use parameterised queries, never string-concatenate user input into SQL. <strong>XSS</strong>: sanitise output, use Content Security Policy headers. <strong>CSRF</strong>: use same-site cookies and CSRF tokens. <strong>Rate limiting</strong>: protect login endpoints from brute-force attacks.</p>\n\n<h3>Summary</h3>\n<p>Security is built on threat modelling: understand what attackers want, how they might get it, and design your system to make each attack infeasible. The OWASP Top 10 is your starting checklist.</p>",
  "quiz": [
    {
      "question": "What is the difference between authentication and authorisation?",
      "options": [
        "They are the same thing",
        "Authentication verifies identity; authorisation determines what a user can access",
        "Authorisation verifies identity; authentication determines permissions",
        "Authentication only applies to APIs; authorisation only applies to UIs"
      ],
      "correct_answer": 1
    },
    {
      "question": "Why should JWTs not be stored in localStorage?",
      "options": [
        "localStorage is too slow for JWT storage",
        "JWTs are too large for localStorage",
        "localStorage is accessible to JavaScript and vulnerable to XSS attacks",
        "localStorage does not persist across page reloads"
      ],
      "correct_answer": 2
    },
    {
      "question": "What prevents SQL injection attacks?",
      "options": [
        "Encrypting the database",
        "Using parameterised queries instead of string concatenation",
        "Storing passwords as plaintext",
        "Disabling user input fields"
      ],
      "correct_answer": 1
    },
    {
      "question": "What is CSRF?",
      "options": [
        "A type of SQL injection attack",
        "Cross-Site Request Forgery — tricking a logged-in user's browser into making unauthorised requests",
        "A method for encrypting cookies",
        "A network protocol for secure file transfer"
      ],
      "correct_answer": 1
    },
    {
      "question": "What is the purpose of bcrypt when storing passwords?",
      "options": [
        "To encrypt passwords for transmission",
        "To hash passwords with a salt so they cannot be reversed even if the database is breached",
        "To validate password complexity rules",
        "To generate JWT tokens from passwords"
      ],
      "correct_answer": 1
    }
  ]
}
