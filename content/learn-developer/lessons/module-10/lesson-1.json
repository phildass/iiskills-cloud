{
  "moduleId": 10,
  "lessonId": 1,
  "slug": "advanced-patterns-clean-code",
  "title": "Advanced Patterns & Clean Code",
  "isFree": false,
  "content": "<h2>Module 10, Lesson 1: Advanced Patterns &amp; Clean Code</h2>\n\n<h3>The Hook</h3>\n<p>Writing code that works is table stakes. Writing code that other developers (including future-you) can read, understand, and safely modify is the mark of a professional. Clean code, design patterns, and SOLID principles are the shared vocabulary that lets teams move fast without breaking things.</p>\n\n<h3>The Concept</h3>\n<h4>SOLID Principles</h4>\n<p><strong>Single Responsibility</strong>: a class/function should do one thing and do it well. <strong>Open/Closed</strong>: open for extension, closed for modification. <strong>Liskov Substitution</strong>: subtypes must be substitutable for their base types. <strong>Interface Segregation</strong>: prefer many small interfaces over one large one. <strong>Dependency Inversion</strong>: depend on abstractions, not concrete implementations.</p>\n<h4>Design Patterns</h4>\n<p><strong>Creational</strong> patterns (Factory, Singleton, Builder) manage object creation. <strong>Structural</strong> patterns (Adapter, Decorator, Proxy) compose objects into larger structures. <strong>Behavioural</strong> patterns (Observer, Strategy, Command) define how objects communicate. Don't apply patterns for their own sake — apply them when they solve a real problem you have.</p>\n<h4>Testing Strategy</h4>\n<p>The testing pyramid: many unit tests (fast, isolated), fewer integration tests, fewest end-to-end tests. Unit tests give rapid feedback; E2E tests catch user-facing regressions. Test behaviour, not implementation — tests coupled to implementation details break on every refactor.</p>\n\n<h3>The Illustration</h3>\n<p>Clean code is an investment. The time spent writing readable, well-tested code pays back many times over in reduced debugging, easier onboarding, and safer refactoring. Patterns and principles are tools — use them thoughtfully.</p>",
  "quiz": [
    {
      "question": "What does the Single Responsibility Principle (SRP) state?",
      "options": [
        "A function should only be called once",
        "A class or function should have only one reason to change",
        "Each developer should work on only one feature at a time",
        "A module should export only one function"
      ],
      "correct_answer": 1
    },
    {
      "question": "What is the Observer design pattern?",
      "options": [
        "A pattern where one object watches another for security breaches",
        "A pattern where an object notifies a list of dependents automatically when its state changes",
        "A pattern for logging all function calls",
        "A pattern for lazy initialisation of objects"
      ],
      "correct_answer": 1
    },
    {
      "question": "What is the testing pyramid?",
      "options": [
        "A hierarchical structure for organising test files",
        "A visual model showing many unit tests, fewer integration tests, and fewest E2E tests",
        "A management structure for QA teams",
        "A framework for test-driven development"
      ],
      "correct_answer": 1
    },
    {
      "question": "What does the Dependency Inversion Principle mean?",
      "options": [
        "High-level modules should not depend on low-level modules; both should depend on abstractions",
        "You should never inject dependencies into constructors",
        "Dependencies should be loaded in reverse order",
        "Each module should have its own copy of shared dependencies"
      ],
      "correct_answer": 0
    },
    {
      "question": "Why should tests target behaviour rather than implementation?",
      "options": [
        "Behaviour tests are faster to run",
        "Implementation tests require more memory",
        "Tests coupled to implementation break on every internal refactor even when behaviour is unchanged",
        "Behaviour tests cover more lines of code"
      ],
      "correct_answer": 2
    }
  ]
}
